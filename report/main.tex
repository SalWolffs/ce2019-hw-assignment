\documentclass[a4paper,twoside]{article}

\input{preamble.tex}

\newcommand{\atom}[1]{\mbox{\texttt{#1}}}

\usepackage{rwd-drafting}

\title{Cryptographic Engineering ECC Project}

\author{Sal Wolffs, Lars Jellema}

\begin{document}
\maketitle

\section*{Exercise 4} 
\atom{modaddn.vhd} was written by copying \atom{modadd4.vhd} and replacing any
occurrences of \atom{3} and \atom{4} by \atom{n-1} resp. \atom{n}, as per the
example of \atom{addn.vhd} and \atom{add4.vhd}. Expanding the test bench was
done by adjusting the default width of the generic \atom{tb\_modaddn} entity,
taking some 128-bit random numbers for \atom{a\_i}, \atom{b\_i} and \atom{p\_i},
making sure one set requires a subtraction and one doesn't, and computing
appropriate values for \atom{sum\_true} in python.

\section*{Exercise 7}
For \atom{modaddn\_mult.vhd}, we wrote a separate file for the finite state
machine (TODO: add full paragraph on \atom{ctr\_fsm}) and added it and
\atom{modaddn} as components. \atom{modaddsubn} was not needed here, we know
we'll only do additions. We adjusted the FSM to hold "done" after reaching its
limit, rather than resetting. 

\section*{Exercise 8}
We wrote a modular piso left shift register (i.e. one that outputs the MSB and
shifts it out on each cycle) \atom{piso\_lshiftreg} to scan through the bits of
\atom{b} in \atom{modmultn}. We also wrote a modulo left shifter which shifts
its input by 1 bit and reduces it modulo the given \atom{p}, using the same
logic as in \atom{modaddn}. Re-using \atom{ctr\_fsm}, this time with the width
of \atom{b} as constant input (TODO: might be able to optimise by hardcoding
within \atom{ctr\_fsm}, at the cost of losing this re-use), we could now easily
double-and-add modulo p within the main module.

\section*{Exercise 9}
The basic design is a simple glueing of earlier components with
some muxes and input buffers: \atom{modmultn} has buffered input and only
updates its inputs on receiving "start".  \atom{modaddsubn} is asynchronous, and
so will compute whenever inputs change.  In the interest of keeping energy
consumption low, we buffer the inputs of \atom{modaddsubn} as well in the
\atom{modarithn} unit. All commands except "01" are done as soon as \atom{start}
is released (actually, they're done on the next rising edge after clock, but
coding that ran into vhdl syntax issues). So a mux selects \atom{done} from
either the \atom{done} output of the multiplier (on command "01") or otherwise
just outputs \atom{not start}. Output is chosen by mux based on the command from
either \atom{modmultn}, \atom{modaddsubn}, or just the \atom{a} input (on
\atom{NOP}) based on command received. The \atom{cmd\_reg} allows us to adjust
the design to deal with the \atom{command} input becoming unstable after
\atom{start} goes low.


\section*{Exercise 14}
Since serially loading values into registers causes quite a bit of overhead, we
added a component \atom{ecc\_core\_wrap} which presents an external parallel
interface like most ALU-like units in this project. Internally, the main
component is an instance of \atom{ecc\_add\_double}. On receiving the
start signal, it iterates a pointer over the necessary RAM locations, setting
\atom{m\_address} and \atom{m\_din} as appropriate. Then, it waits for
\atom{ecc\_add\_double} to signal it's done, reads the result values into
parallel registers, and then sets its own done signal.

Given the above interface, the actual Montgomery ladder unit \atom{ecc\_ladder}
becomes relatively simple. For convenience, we've bundled sets of numbers
comprising a projective point on the curve into a data type. On all incoming and
outgoing signals (both on our interface and on that of components), we bundle
and unbundle such sets from/to three signals to/from one.

We have three main data registers: \atom{R0\_reg}, \atom{R1\_reg}, and
\atom{k\_reg} (where k is the input scalar). On start, we load these, and on the
next cycle, we start calculation. We also keep a countdown from $n-1$ as per the
loop in the Montgomery ladder algorithm.

Notably, this component does not contain an explicit FSM. This is because we're
tremendously helped by the regularity of the algorithm: once the core unit is
done, we move to the next step. Steps always alternate between adding and
doubling. Which register to double is determined by $k_i$. Which register to
write to is determined by $k_i$ and whether we doubled. The core should always
start a cycle after it's done, because we've clocked in the proper results at
that point (note: there is likely a timing issue here, and we should add a
1-clock delay). Our $k_i$ index is lowered every second step, which is when the
core is done and we've just doubled. The unit is done once we've doubled and
$k_i$ is 0.

Unfortunately, running the testbench \atom{tb\_ecc\_ladder}, beside being slow
(running about 1ms per minute), actually managed to crash GHDL. Since GHDL
claimed this was its own fault (reporting it as a GHDL bug with a request to
report it), we don't have a specific idea how to get around this, or what might
be wrong. Therefore, we haven't been able to test \atom{ecc\_ladder} despite
haivng written the testbench.

\section*{Exercise 15}
Unfortunately, we haven't been able to implement any of the things we'd planned
after running into the testbench issue, since optimizing an untested unit is a
fool's errand. Nonetheless, we had some plans:
\begin{itemize}
    \item Change the RAM interface to allow both parallel and addressed access,
        obviating the need for a \atom{ecc\_core\_wrap}.
    \item There are a lot of redundant registers on the inputs of the various
        components. Since we know the outer components keep the inputs stable,
        we can remove those, at the cost of some generality for the individual
        components but gaining both clock cycles and space.
    \item It should be doable to add a tripler to the modarithn unit, which
        would allow some compression of the point arithmetic instructions. This
        would also allow us to reorder the helper variables to use one less.
    \item We could rewrite the assembly to do in-place computation of the point
        arithmetic, saving enough memory words to actually shrink our address
        space by one bit.
\end{itemize}

\end{document}
