\documentclass[a4paper,twoside]{article}

\input{preamble.tex}

\newcommand{\atom}[1]{\mbox{\texttt{#1}}}

\usepackage{rwd-drafting}

\title{Cryptographic Engineering ECC Project}

\author{Sal Wolffs, s4064542
\\ Lars Jellema, s4388747}

\begin{document}
\maketitle

\section*{Exercise 4}
\atom{modaddn.vhd} was written by copying \atom{modadd4.vhd} and replacing any
occurrences of \atom{3} and \atom{4} by \atom{n-1} resp. \atom{n}, as per the
example of \atom{addn.vhd} and \atom{add4.vhd}. Expanding the test bench was
done by adjusting the default width of the generic \atom{tb\_modaddn} entity,
taking some 128-bit random numbers for \atom{a\_i}, \atom{b\_i} and \atom{p\_i},
making sure one set requires a subtraction and one doesn't, and computing
appropriate values for \atom{sum\_true} in python.

\section*{Exercise 7}
For \atom{modaddn\_mult.vhd}, we wrote a separate file for the finite state
machine, \atom{ctr\_fsm}, which it includes as a component. The FSM consists of
a table of transitions depending on the input signals and triggered by the
clock. A separate process computes the outputs based on the current state. The
FSM is a generic one that simply counts for a number of cycles specified in an
input, which allows us to reuse it in several components.

Because the multiplier is defined in terms of only additions, we use a
\atom{modaddn} rather than a \atom{modaddsubn}. We adjusted the FSM to hold
"done" after reaching its limit, rather than resetting.

\section*{Exercise 8}
We wrote a modular piso left shift register (i.e. one that outputs the MSB and
shifts it out on each cycle) \atom{piso\_lshiftreg} to scan through the bits of
\atom{b} in \atom{modmultn}. We also wrote a modulo left shifter which shifts
its input by 1 bit and reduces it modulo the given \atom{p}, using the same
logic as in \atom{modaddn}. Re-using \atom{ctr\_fsm}, this time with the width
of \atom{b} as constant input, we could now easily double-and-add modulo p
within the main module.

\section*{Exercise 9}
The basic design is a simple glueing of earlier components with
some muxes and input buffers: \atom{modmultn} has buffered input and only
updates its inputs on receiving "start".  \atom{modaddsubn} is asynchronous, and
so will compute whenever inputs change.  In the interest of keeping energy
consumption low, we buffer the inputs of \atom{modaddsubn} as well in the
\atom{modarithn} unit. All commands except "01" are done as soon as \atom{start}
is released (actually, they're done on the next rising edge after clock, but
coding that ran into vhdl syntax issues). So a mux selects \atom{done} from
either the \atom{done} output of the multiplier (on command "01") or otherwise
just outputs \atom{not start}. Output is chosen by mux based on the command from
either \atom{modmultn}, \atom{modaddsubn}, or just the \atom{a} input (on
\atom{NOP}) based on command received. The \atom{cmd\_reg} allows us to adjust
the design to deal with the \atom{command} input becoming unstable after
\atom{start} goes low.

\section*{Exercise 11}
\atom{ram\_double} is a copy of \atom{ram\_single} with references to
\atom{dout} duplicated into \atom{dout\_a} and \atom{dout\_b}. \atom{address} is
similarly duplicated, while \atom{din} is simply renamed to \atom{din\_a}.

\section*{Exercise 12}
For simplicity, we've separated the FSM in this exercise from the remaining
logic. The FSM is implemented in \atom{ecc\_fsm} and is a direct implementation
of the FSM described in the exercise, with one exception: In the
\atom{s\_load\_arith} state, we set \atom{free} to 0 rather than 1. We believe
the specification is in error here as it suggests loading directly from external
RAM while the operations described in exercise 13 suggest all operands are
stored in internal RAM instead. We use one process to describe the state
transitions based on the input, which is triggered on reset and by the clock,
and another process to set the outputs based only on the current state.

The main \atom{ecc\_base} implementation instantiates an arithmetic unit, a
two-operand internal RAM and the FSM mentioned above. The logic is exactly as
described in the schematic from exercise 12. Because the FSM is in another file,
the only parts left are creating the mutexes to switch between internal and
external RAM and setting the current command and operands when the start signal
is high.

\section*{Exercise 13}
We chose to use an instruction ROM to describe the addition and doubling
formulas. It uses a simple Very Long Instruction Word architecture which
directly maps the operands and command into the 18-bit instructions. The
instruction ROM is generated using a simple Python script, see
\atom{rbc\_rom.py}.

\atom{ecc\_add\_double} uses \atom{rbc\_rom} by wiring its output directly to
the \atom{ecc\_core} and incrementing the instruction pointer every time
\atom{ecc\_core} sets its \atom{done} signal. We've corrected one bug in the
NIST test: It used the value 256 for \atom{n}, but 3 for \atom{log2n}. The
correct logarithm of \atom{n} is of course 8 and the compiler gave a warning
when it wasn't equal to 8.

\section*{Exercise 14}
Since serially loading values into registers causes quite a bit of overhead, we
added a component \atom{ecc\_core\_wrap} which presents an external parallel
interface like most ALU-like units in this project. Internally, the main
component is an instance of \atom{ecc\_add\_double}. On receiving the
start signal, it iterates a pointer over the necessary RAM locations, setting
\atom{m\_address} and \atom{m\_din} as appropriate. Then, it waits for
\atom{ecc\_add\_double} to signal it's done, reads the result values into
parallel registers, and then sets its own done signal.

Given the above interface, the actual Montgomery ladder unit \atom{ecc\_ladder}
becomes relatively simple. For convenience, we've bundled sets of numbers
comprising a projective point on the curve into a data type. On all incoming and
outgoing signals (both on our interface and on that of components), we bundle
and unbundle such sets from/to three signals to/from one.

We have three main data registers: \atom{R0\_reg}, \atom{R1\_reg}, and
\atom{k\_reg} (where k is the input scalar). On start, we load these, and on the
next cycle, we start calculation. We also keep a countdown from $n-1$ as per the
loop in the Montgomery ladder algorithm.

Notably, this component does not contain an explicit FSM. This is because we're
tremendously helped by the regularity of the algorithm: once the core unit is
done, we move to the next step. Steps always alternate between adding and
doubling. Which register to double is determined by $k_i$. Which register to
write to is determined by $k_i$ and whether we doubled. The core should always
start a cycle after it's done, because we've clocked in the proper results at
that point (note: there is likely a timing issue here, and we should add a
1-clock delay). Our $k_i$ index is lowered every second step, which is when the
core is done and we've just doubled. The unit is done once we've doubled and
$k_i$ is 0.

Unfortunately, running the testbench \atom{tb\_ecc\_ladder}, beside being slow
(running about 1ms per minute), actually managed to crash GHDL. Since GHDL
claimed this was its own fault (reporting it as a GHDL bug with a request to
report it), we don't have a specific idea how to get around this, or what might
be wrong. Therefore, we haven't been able to test \atom{ecc\_ladder} despite
haivng written the testbench.

\section*{Exercise 15}
Unfortunately, we haven't been able to implement any of the things we'd planned
after running into the testbench issue, since optimizing an untested unit is a
fool's errand. Nonetheless, we had some plans:
\begin{itemize}
    \item Change the RAM interface to allow both parallel and addressed access,
        obviating the need for a \atom{ecc\_core\_wrap}.
    \item There are a lot of redundant registers on the inputs of the various
        components. Since we know the outer components keep the inputs stable,
        we can remove those, at the cost of some generality for the individual
        components but gaining both clock cycles and space.
    \item It should be doable to add a tripler to the modarithn unit, which
        would allow some compression of the point arithmetic instructions. This
        would also allow us to reorder the helper variables to use one less.
    \item We could rewrite the assembly to do in-place computation of the point
        arithmetic, saving enough memory words to actually shrink our address
        space by one bit.
\end{itemize}

\section*{Conclusion}

All in all, the course was quite fun, but a little rough around the edges. We
had to figure out how to write decent VHDL code without ever being taught the
relevant common wisdom. For example, it was sometimes unclear which component
was supposed to be responsible for synchronization. There were also a few bugs
in the assignment tests and description which are described above.

Due to mistakes on our side we ran out of time, so our submission is a little
rough around the edges as well.

\end{document}
