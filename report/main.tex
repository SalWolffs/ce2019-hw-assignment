\documentclass[a4paper,twoside]{article}

\input{preamble.tex}

\newcommand{\atom}[1]{\mbox{\texttt{#1}}}

\usepackage{rwd-drafting}

\title{Cryptographic Engineering ECC Project}

\author{Sal Wolffs, Lars Jellema}

\begin{document}
\maketitle

\section*{Exercise 4} 
\atom{modaddn.vhd} was written by copying \atom{modadd4.vhd} and replacing any
occurrences of \atom{3} and \atom{4} by \atom{n-1} resp. \atom{n}, as per the
example of \atom{addn.vhd} and \atom{add4.vhd}. Expanding the test bench was
done by adjusting the default width of the generic \atom{tb\_modaddn} entity,
taking some 128-bit random numbers for \atom{a\_i}, \atom{b\_i} and \atom{p\_i},
making sure one set requires a subtraction and one doesn't, and computing
appropriate values for \atom{sum\_true} in python.

\section*{Exercise 7}
For \atom{modaddn\_mult.vhd}, we wrote a separate file for the finite state
machine (TODO: add full paragraph on \atom{ctr\_fsm}) and added it and
\atom{modaddn} as components. \atom{modaddsubn} was not needed here, we know
we'll only do additions. We adjusted the FSM to hold "done" after reaching its
limit, rather than resetting. 

\section*{Exercise 8}
We wrote a modular piso left shift register (i.e. one that outputs the MSB and
shifts it out on each cycle) \atom{piso\_lshiftreg} to scan through the bits of
\atom{b} in \atom{modmultn}. We also wrote a modulo left shifter which shifts
its input by 1 bit and reduces it modulo the given \atom{p}, using the same
logic as in \atom{modaddn}. Re-using \atom{ctr\_fsm}, this time with the width
of \atom{b} as constant input (TODO: might be able to optimise by hardcoding
within \atom{ctr\_fsm}, at the cost of losing this re-use), we could now easily
double-and-add modulo p within the main module.

\section*{Exercise 9}
TODO: Drawing. The basic design is a simple glueing of earlier components with
some muxes and input buffers: \atom{modmultn} has buffered input and only
updates its inputs on receiving "start".  \atom{modaddsubn} is asynchronous, and
so will compute whenever inputs change.  In the interest of keeping energy
consumption low, we buffer the inputs of \atom{modaddsubn} as well in the
\atom{modarithn} unit. All commands except "01" are done as soon as \atom{start}
is released (actually, they're done on the next rising edge after clock, but
coding that ran into vhdl syntax issues). So a mux selects \atom{done} from
either the \atom{done} output of the multiplier (on command "01") or otherwise
just outputs \atom{not start}. Output is chosen by mux based on the command from
either \atom{modmultn}, \atom{modaddsubn}, or just the \atom{a} input (on
\atom{NOP}) based on command received. The \atom{cmd\_reg} allows us to adjust
the design to deal with the \atom{command} input becoming unstable after
\atom{start} goes low.

\section*{Exercise 11}
\atom{ram\_double} is a copy of \atom{ram\_single} with references to
\atom{dout} duplicated into \atom{dout\_a} and \atom{dout\_b}. \atom{address} is
similarly duplicated, while \atom{din} is simply renamed to \atom{din\_a}.

\section*{Exercise 12}
For simplicity, we've separated the FSM in this exercise from the remaining
logic. The FSM is implemented in \atom{ecc\_fsm} and is a direct implementation
of the FSM described in the exercise, with one exception: In the
\atom{s\_load\_arith} state, we set \atom{free} to 0 rather than 1. We believe
the specification is in error here as it suggests loading directly from external
RAM while the operations described in exercise 13 suggest all operands are
stored in internal RAM instead. We use one process to describe the state
transitions based on the input, which is triggered on reset and by the clock,
and another process to set the outputs based only on the current state.

The main \atom{ecc\_base} implementation instantiates an arithmetic unit, a
two-operand internal RAM and the FSM mentioned above. The logic is exactly as
described in the schematic from exercise 12. Because the FSM is in another file,
the only parts left are creating the mutexes to switch between internal and
external RAM and setting the current command and operands when the start signal
is high.

\section*{Exercise 13}
We chose to use an instruction ROM to describe the addition and doubling
formulas. It uses a simple Very Long Instruction Word architecture which
directly maps the operands and command into the 18-bit instructions. The
instruction ROM is generated using a simple Python script, see
\atom{rbc\_rom.py}.

\atom{ecc\_add\_double} uses \atom{rbc\_rom} by wiring its output directly to
the \atom{ecc\_core} and incrementing the instruction pointer every time
\atom{ecc\_core} sets its \atom{done} signal. We've corrected one bug in the
NIST test: It used the value 256 for \atom{n}, but 3 for \atom{log2n}. The
correct logarithm of \atom{n} is of course 8 and the compiler gave a warning
when it wasn't equal to 8.

\end{document}
